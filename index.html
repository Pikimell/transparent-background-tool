<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transparent Background Tool</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better visual experience */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f4f7f9;
        }
        /* Style for the canvas to show the transparency effect - applied to all result cards */
        .result-canvas {
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1); /* Subtle border */
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
                              linear-gradient(-45deg, #ccc 25%, transparent 25%),
                              linear-gradient(45deg, transparent 75%, #ccc 75%),
                              linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 16px 16px;
            background-position: 0 0, 0 8px, 8px -8px, -8px 0px;
            max-width: 100%;
            height: auto;
            border-radius: 0.5rem;
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <div id="appContainer" class="w-full max-w-5xl bg-white p-6 md:p-10 rounded-xl shadow-2xl space-y-8">
        <header class="text-center space-y-2">
            <h1 class="text-4xl font-extrabold text-gray-800">Transparent Background Tool</h1>
            <p class="text-gray-500">Завантажте **декілька** зображень, оберіть колір, який потрібно зробити прозорим, та обробіть їх одним кліком.</p>
        </header>

        <!-- File Upload Area -->
        <div class="border-2 border-dashed border-indigo-300 rounded-lg p-6 hover:border-indigo-500 transition duration-300 cursor-pointer">
            <!-- Added 'multiple' attribute here -->
            <input type="file" id="imageUpload" accept="image/*" multiple class="hidden" onchange="handleImageUpload(event)">
            <label for="imageUpload" class="flex flex-col items-center justify-center space-y-3">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-indigo-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                </svg>
                <span class="text-lg font-semibold text-indigo-600">Натисніть, щоб завантажити зображення (можна декілька)</span>
                <span class="text-sm text-gray-500">PNG, JPG, або GIF</span>
            </label>
        </div>

        <!-- Status Message Area -->
        <div id="statusMessage" class="text-center font-medium h-6"></div>

        <!-- Color and Tolerance Controls -->
        <div id="settingsArea" class="hidden bg-gray-50 p-4 rounded-lg border">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Налаштування Фону для Видалення</h2>
            
            <div class="flex flex-col md:flex-row gap-6 items-center">
                <!-- Color Picker -->
                <div class="flex-1 space-y-2 w-full">
                    <label for="colorInput" class="block text-sm font-medium text-gray-700">Вибрати Колір Фону (HEX):</label>
                    <div class="flex items-center gap-3">
                        <input type="color" id="colorInput" value="#FFFFFF" onchange="updateTargetColor(event.target.value)" 
                               class="w-12 h-12 border border-gray-300 rounded-md cursor-pointer p-0.5">
                        <span id="selectedColorDisplay" class="font-mono text-gray-600">#FFFFFF</span>
                    </div>
                </div>

                <!-- Tolerance Slider -->
                <div class="flex-1 space-y-2 w-full">
                    <label for="toleranceSlider" class="block text-sm font-medium text-gray-700">
                        Толерантність Кольору: <span id="toleranceValue" class="font-bold text-indigo-600">10</span>
                    </label>
                    <input type="range" id="toleranceSlider" min="1" max="50" value="10" 
                           oninput="updateTolerance(event.target.value)"
                           class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    <p class="text-xs text-gray-500">
                        Вищий показник = видалення більшої кількості схожих відтінків.
                    </p>
                </div>
            </div>
        </div>

        <!-- Controls (Process All) -->
        <div id="controls" class="hidden flex justify-center pt-4">
            <button id="processButton" onclick="processAllFiles()" class="px-8 py-4 bg-indigo-600 text-white font-bold text-lg rounded-lg shadow-xl hover:bg-indigo-700 transition duration-150 transform hover:scale-105 disabled:opacity-50" disabled>
                ОБРОБИТИ ВСІ <span id="fileCount">0</span> ЗОБРАЖЕНЬ
            </button>
        </div>

        <!-- Results Display Area (NEW: Container for multiple cards) -->
        <div id="resultsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <!-- Result cards will be injected here -->
        </div>
    </div>

    <script>
        // Global references
        const statusMessage = document.getElementById('statusMessage');
        const imageUpload = document.getElementById('imageUpload');
        const settingsArea = document.getElementById('settingsArea');
        const colorInput = document.getElementById('colorInput');
        const selectedColorDisplay = document.getElementById('selectedColorDisplay');
        const toleranceSlider = document.getElementById('toleranceSlider');
        const toleranceValueSpan = document.getElementById('toleranceValue');
        const resultsContainer = document.getElementById('resultsContainer');
        const processButton = document.getElementById('processButton');
        const fileCountSpan = document.getElementById('fileCount');

        let uploadedFiles = []; // Array to store uploaded File objects
        
        // Custom color removal state
        let targetRgb = { r: 255, g: 255, b: 255 }; // Default to white
        let tolerance = 10; // Default tolerance

        /**
         * Utility function to convert HEX color string to RGB object.
         * @param {string} hex The hex color string (e.g., "#FF0000").
         * @returns {object|null} RGB object {r, g, b} or null on failure.
         */
        function hexToRgb(hex) {
            const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, function(m, r, g, b) {
                return r + r + g + g + b + b;
            });

            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        /**
         * Updates the target RGB color based on the color picker value.
         * @param {string} hexColor The new hex color from the input.
         */
        function updateTargetColor(hexColor) {
            const rgb = hexToRgb(hexColor);
            if (rgb) {
                targetRgb = rgb;
                selectedColorDisplay.textContent = hexColor.toUpperCase();
            }
        }

        /**
         * Updates the color tolerance based on the slider value.
         * @param {string} value The new tolerance value (string).
         */
        function updateTolerance(value) {
            tolerance = parseInt(value, 10);
            toleranceValueSpan.textContent = tolerance;
        }

        /**
         * Handles the upload of one or multiple files.
         * @param {Event} event The file change event.
         */
        function handleImageUpload(event) {
            const files = event.target.files;
            if (files.length === 0) return;

            // Clear previous state
            uploadedFiles = [];
            resultsContainer.innerHTML = '';
            statusMessage.textContent = '';

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                if (file.type.startsWith('image/')) {
                    uploadedFiles.push(file);
                } else {
                    console.warn(`Skipping non-image file: ${file.name}`);
                }
            }

            if (uploadedFiles.length > 0) {
                settingsArea.classList.remove('hidden');
                document.getElementById('controls').classList.remove('hidden');
                processButton.disabled = false;
                fileCountSpan.textContent = uploadedFiles.length;
                statusMessage.textContent = `Завантажено ${uploadedFiles.length} зображень. Готово до обробки.`;
                statusMessage.classList.add('text-green-600');
            } else {
                settingsArea.classList.add('hidden');
                document.getElementById('controls').classList.add('hidden');
                processButton.disabled = true;
                statusMessage.textContent = 'Не завантажено жодного дійсного зображення.';
                statusMessage.classList.add('text-red-500');
            }
        }

        /**
         * Iterates through all uploaded files and starts the processing for each.
         */
        function processAllFiles() {
            if (uploadedFiles.length === 0) {
                statusMessage.textContent = 'Будь ласка, завантажте зображення.';
                statusMessage.classList.add('text-red-500');
                return;
            }

            processButton.disabled = true;
            resultsContainer.innerHTML = ''; // Clear previous results

            statusMessage.textContent = `Початок обробки ${uploadedFiles.length} файлів...`;
            statusMessage.classList.remove('text-red-500');
            statusMessage.classList.add('text-indigo-600');

            // Process files sequentially or in parallel (here we do sequential reads, parallel processing)
            uploadedFiles.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        createResultCard(img, file.name);
                    };
                    img.onerror = () => {
                        console.error(`Error loading image data for ${file.name}`);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });

            // Re-enable button after starting the batch process
            setTimeout(() => {
                 processButton.disabled = false;
                 statusMessage.textContent = `Обробка розпочата. Перевірте результати нижче.`;
                 statusMessage.classList.remove('text-indigo-600');
                 statusMessage.classList.add('text-green-600');
            }, 500);
        }
        
        /**
         * Creates a result card for a single image and initiates background removal.
         * @param {HTMLImageElement} img The loaded image element.
         * @param {string} originalFileName The original name of the file.
         */
        function createResultCard(img, originalFileName) {
            // 1. Prepare card structure
            const card = document.createElement('div');
            card.className = 'bg-white border rounded-xl shadow-lg p-4 space-y-3';
            
            // 2. Add filename title
            const title = document.createElement('h3');
            title.className = 'text-base font-semibold text-gray-800 truncate';
            title.textContent = originalFileName;
            card.appendChild(title);
            
            // 3. Add original preview (resized)
            const originalDiv = document.createElement('div');
            originalDiv.className = 'flex justify-center items-center h-32 bg-gray-100 rounded-lg overflow-hidden';
            const originalThumb = document.createElement('img');
            originalThumb.src = img.src;
            originalThumb.className = 'max-h-full max-w-full';
            originalDiv.appendChild(originalThumb);
            card.appendChild(originalDiv);
            
            // 4. Add result canvas
            const canvas = document.createElement('canvas');
            canvas.className = 'result-canvas';
            card.appendChild(canvas);
            
            // 5. Add status/download link
            const downloadStatusDiv = document.createElement('div');
            downloadStatusDiv.className = 'flex justify-center pt-2';
            const downloadLink = document.createElement('a');
            
            // --- Determine new download filename (REQUIREMENT) ---
            const nameParts = originalFileName.split('.');
            let baseName, extension;
            if (nameParts.length > 1) {
                extension = nameParts.pop(); // Get extension (not used for PNG but good practice)
                baseName = nameParts.join('.');
            } else {
                baseName = originalFileName;
            }
            const newFileName = `${baseName}_v2.png`;
            
            downloadLink.download = newFileName;
            downloadLink.textContent = 'Завантажити ' + newFileName;
            downloadLink.className = 'hidden px-4 py-2 bg-green-500 text-white font-bold rounded-lg shadow-md hover:bg-green-600 transition duration-150 text-sm';
            downloadStatusDiv.appendChild(downloadLink);
            card.appendChild(downloadStatusDiv);
            
            // 6. Append card to container
            resultsContainer.appendChild(card);
            
            // 7. Process the image on the new canvas
            processSingleImage(img, canvas, downloadLink);
        }

        /**
         * Performs background removal on a single image and updates the UI card.
         * @param {HTMLImageElement} img The loaded HTML image element.
         * @param {HTMLCanvasElement} canvas The canvas element for the result.
         * @param {HTMLAnchorElement} downloadLink The download link to update.
         */
        function processSingleImage(img, canvas, downloadLink) {
            try {
                const w = img.width;
                const h = img.height;
                canvas.width = w;
                canvas.height = h;

                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, w, h);

                const imageData = ctx.getImageData(0, 0, w, h);
                const data = imageData.data;

                // Target color components and tolerance
                const tr = targetRgb.r;
                const tg = targetRgb.g;
                const tb = targetRgb.b;
                const tol = tolerance;

                // Iterate through all pixels (r, g, b, a)
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];     // Red
                    const g = data[i + 1]; // Green
                    const b = data[i + 2]; // Blue

                    // Check if the pixel color is within the tolerance range of the target color
                    const rDiff = Math.abs(r - tr);
                    const gDiff = Math.abs(g - tg);
                    const bDiff = Math.abs(b - tb);
                    
                    // Simple check: if the max difference in any channel is less than or equal to tolerance
                    if (rDiff <= tol && gDiff <= tol && bDiff <= tol) {
                        // Set Alpha channel (data[i + 3]) to 0 (fully transparent)
                        data[i + 3] = 0;
                    }
                }

                ctx.putImageData(imageData, 0, 0);

                // Prepare the download link
                const dataURL = canvas.toDataURL('image/png');
                downloadLink.href = dataURL;
                downloadLink.classList.remove('hidden');

            } catch (error) {
                console.error("Single image processing failed:", error);
                // Display error on the download link area
                downloadLink.parentElement.textContent = 'Помилка обробки!';
            }
        }
        
        // Initialization
        updateTargetColor(colorInput.value);
        updateTolerance(toleranceSlider.value);
    </script>
</body>
</html>
